{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Laboratorium 7 - Kwadratury adaptacyjne\n"
      ],
      "id": "a1ef77bd"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "import pandas as pd\n",
        "from scipy import integrate\n",
        "import seaborn as sns\n",
        "from IPython.display import display\n",
        "\n",
        "sns.set_style(\"darkgrid\")"
      ],
      "id": "db2a9703",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Zadanie 2.\n",
        "Powtórz obliczenia z poprzedniego oraz dzisiejszego laboratorium dla całek:\n",
        "\n",
        "(a)   $\\int_0^1 \\sqrt{x}\\log xdx = - \\frac{4}{9}$\n",
        "\n",
        "\n",
        "(b)   $\\int_0^1 \\Big(\\frac{1}{(x-0.3)^2 + a} + \\frac{1}{(x-0.9)^2 + b} - 6 \\Big) dx$\n"
      ],
      "id": "be098426"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "def plot_error_func(f, real_value):\n",
        "    a = 0 + np.finfo(np.double).eps\n",
        "    b = 1\n",
        "    m_vec = np.arange(1, 26)\n",
        "\n",
        "    def quad_int(xs, f):\n",
        "        s = 0\n",
        "        for i in range(len(xs) - 1):\n",
        "            dx = xs[i + 1] - xs[i]\n",
        "            x = (xs[i] + xs[i + 1]) / 2\n",
        "            s += f(x) * dx\n",
        "        return s\n",
        "\n",
        "    def trap(xs, f):\n",
        "        return integrate.trapezoid([f(xs)], x=xs)\n",
        "\n",
        "    def simpson(xs, f):\n",
        "        return integrate.simpson(f(xs), x=xs)\n",
        "\n",
        "    def trap_adaptive(epsrel):\n",
        "        return integrate.quad_vec(\n",
        "            f,\n",
        "            a + np.finfo(np.double).eps,\n",
        "            b,\n",
        "            epsrel=epsrel,\n",
        "            quadrature=\"trapezoid\",\n",
        "            full_output=True,\n",
        "        )\n",
        "\n",
        "    def gauss_kronrod(epsrel):\n",
        "        return integrate.quad_vec(\n",
        "            f, a, b, epsrel=epsrel, quadrature=\"gk21\", full_output=True\n",
        "        )\n",
        "\n",
        "    values_list = []\n",
        "    formula_list = [quad_int, trap, simpson]\n",
        "    formula_list_2 = [trap_adaptive, gauss_kronrod]\n",
        "\n",
        "    for formula in formula_list:\n",
        "        values = []\n",
        "        n_nodes = [2**m + 1 for m in m_vec]\n",
        "        x_nodes = [np.linspace(a, b, n) for n in n_nodes]\n",
        "        for nodes in x_nodes:\n",
        "            value = formula(nodes, f)\n",
        "            values.append(value)\n",
        "        values_list.append(values)\n",
        "\n",
        "    m_vec_gauss = np.arange(1, 15)\n",
        "    n_vec_gauss = 2**m_vec_gauss + 1\n",
        "    leggaus_values = [np.polynomial.legendre.leggauss(n) for n in n_vec_gauss]\n",
        "    x_vec_gauss = [x_vec * 0.5 + 0.5 for x_vec, _ in leggaus_values]\n",
        "    y_vec_gauss = [w_vec for _, w_vec in leggaus_values]\n",
        "    gauss_values = [np.sum(f(x) * 0.5 * w) for x, w in zip(x_vec_gauss, y_vec_gauss)]\n",
        "    gauss_errors = [np.abs((value - real_value) / real_value) for value in gauss_values]\n",
        "    errors_list = []\n",
        "\n",
        "    for i, values in enumerate(values_list):\n",
        "        errors = []\n",
        "        for j, value in enumerate(values):\n",
        "            error = np.abs((value - real_value) / real_value)\n",
        "            errors.append(error)\n",
        "        errors_list.append(errors)\n",
        "    x_arr = []\n",
        "    for formula in formula_list_2:\n",
        "        errors = []\n",
        "        x_arr_1 = []\n",
        "        for eps in [x for x in np.logspace(0, -14, 14)]:\n",
        "            result = formula(eps)\n",
        "            err = result[1]\n",
        "            eval_count = result[-1].neval\n",
        "            errors.append(err)\n",
        "            x_arr_1.append(eval_count)\n",
        "        errors_list.append(errors)\n",
        "        x_arr.append(x_arr_1)\n",
        "    plt.figure(figsize=(10, 6))\n",
        "\n",
        "    plt.plot(2**m_vec + 1, errors_list[0], label=\"Rectangular\")\n",
        "    plt.plot(2**m_vec + 1, errors_list[1], label=\"Trapezoidal\")\n",
        "    plt.plot(2**m_vec + 1, errors_list[2], label=\"Simpson\")\n",
        "    plt.plot(2**m_vec_gauss + 1, gauss_errors, label=\"Gauss-Legendre\")\n",
        "    plt.plot(x_arr[0], errors_list[3], label=\"Trap Adaptive\")\n",
        "    plt.plot(x_arr[1], errors_list[4], label=\"Gauss Kronrod\")\n",
        "    plt.yscale(\"log\")\n",
        "    plt.xscale(\"log\")\n",
        "    plt.xlabel(\"Number of nodes\")\n",
        "    plt.ylabel(\"Relative error\")\n",
        "    plt.title(\"Integration error for different methods\")\n",
        "    plt.legend()\n",
        "    plt.show()"
      ],
      "id": "c42e0d70",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Całka (a)\n"
      ],
      "id": "abca899f"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "def fa(x):\n",
        "    return np.sqrt(x) * np.log(x)\n",
        "\n",
        "\n",
        "fa_real = -4 / 9\n",
        "\n",
        "a = 0.001\n",
        "b = 0.004\n",
        "\n",
        "\n",
        "def fb(x):\n",
        "    return 1 / ((x - 0.3) ** 2 + a) + 1 / ((x - 0.9) ** 2 + b) - 6\n",
        "\n",
        "\n",
        "fb_real = (\n",
        "    (1 / np.sqrt(a)) * (np.arctan((1 - 0.3) / np.sqrt(a)) + np.arctan(0.3 / np.sqrt(a)))\n",
        "    + (1 / np.sqrt(b))\n",
        "    * (np.arctan((1 - 0.9) / np.sqrt(b)) + np.arctan(0.9 / np.sqrt(b)))\n",
        "    - 6\n",
        ")\n",
        "\n",
        "# plot_error_func(f, np.pi)\n",
        "plot_error_func(fa, fa_real)"
      ],
      "id": "d0101317",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Całka (b)\n"
      ],
      "id": "42328298"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "plot_error_func(fb, fb_real)"
      ],
      "id": "2594fb64",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Wnioski\n",
        "Ponownie, jak w poprzednim laboratorium, wykresy wyników są wyskalowane logarytmiczne, dlatego przedziały nieciągłości wykresów wskazują, że dla danej liczby węzłów błąd względny jest mniejszy niż precyzja użytych liczb w obliczeniach (w wynikach równa zeru).\n",
        "\n",
        "::: {layout-ncol=3}\n",
        "![Funkcja podcałkowa 1](fbdaae2dc966b14e9c2e42de63dae0bedcc6418f0b33e697979caf8bb63f9dff.png){width=250px}\n",
        "\n",
        "![Funkcja podcałkowa 2A](7f7f998cefe3656f3e71c80a7e60fafc7422dcb8da9ac00c2d02c7a25bfb9e88.png){width=250px}\n",
        "\n",
        "![Funkcja podcałkowa 2B](f39fdbb5c6607ef72040263e69aeccfa26e63603721c069550f073e3989f9120.png){width=250px}\n",
        ":::\n",
        "\n",
        "\n",
        "\n",
        "Dla całki z zadania 1. metoda kwadratur adaptacyjnych trapezów miała większy błąd względny od pozostałych metod, podobnie było w przypadku całki 2 (b), natomiast całkując tą metodą funkcję 2 (a) otrzymamy dokładniejsze wyniki niż przy użyciu metod nieadaptacyjnych.\n",
        "\n",
        "Przy całkowaniu funkcji 1. metoda Gaussa-Kronroda osiągała minimalny błąd, pomijalny w porównaniu z precyzją obliczeń. W zadaniu 2 osiągała większą dokładność od większości metod nieadaptacyjnych, chociaż należy zauważyć, że w niektórych przypadkach metoda Simpsona, czy Gaussa-Legendre'a okazywała się dokładniejsza. Może to też wynikać z przewagi błędu numerycznego nad błędem metody.\n",
        "\n",
        "Porównując wykresy funkcji oraz skuteczność algorytmów można zauważyć, że metody adaptacyjne mają tym większą przewagę, im bardziej \"skomplikowany\" jest wykres funkcji.\n",
        "\n",
        "Podsumowując, metody adaptacyjne, a w szczególności metoda Gaussa-Kronroda dają dokładniejsze wyniki od metod nieadaptacyjnych, ale ich użycie w przypadku prostych funkcji może nie być opłacalne.\n"
      ],
      "id": "917445ab"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "amc_data_jupyter",
      "language": "python",
      "display_name": "AMC data jupyter",
      "path": "/Users/depebul/Library/Jupyter/kernels/amc_data_jupyter"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}